Santino Domato
sdomato@udesa.edu.ar

"phase_1" en esta fase se usa el registro rsi para cargar el string "Los hermanos sean unidos porque esa es la ley primera porque si entre ellos se pelean los devoran los de ajuera" que luego se utiliza para comparar con el registro que tiene la entrada del usuario y si no son iguales salta a explode bomb.

"phase_2" En la fase 2, el programa comienza reservando dinámicamente un pequeño buffer y luego emplea dos llamadas a strtol para parsear exactamente dos enteros decimales (num1 y num2) de la línea de entrada; si no se obtienen ambos valores, o la reserva de memoria falla, la bomba detona inmediatamente. A continuación, calcula una dirección dentro de un buffer o arreglo interno con la fórmula ptr = input_buffer + num1 + num2 – 0x20  y llama a la función misterio(ptr, num1, num2) que realiza dos verificaciones críticas: primero, calcula el bit menos significativo del entero pasado en edi mediante un bucle de 32 iteraciones en las que desplaza aritméticamente el registro y aísla el bit menos significativo para sumar su valor a un acumulador en edx. Si el resultado no coincide exactamente con 11, llama a explode_bomb. A continuación, calcula un XOR entre los dos índices (ebx = esi XOR ebp) y examina el bit de signo; si el resultado es negativo, la bomba también detona.

"phase_3" La función phase_3 comienza leyendo de la entrada estándar una cadena y un entero con sscanf("%s %d",…), asegurándose de que se obtengan exactamente dos valores. Luego reserva memoria y llama a readlines para cargar en un arreglo todas las palabras de palabras.txt. A continuación inicializa un contador a cero y ejecuta la función cuenta, que aplica una búsqueda binaria recursiva sobre el arreglo incrementando el contador en cada llamada y abortando (explode_bomb) si supera 11 recursiones. Cuando cuenta retorna, phase_3 compara el contador resultante con el número ingresado: deben ser iguales y el contador debe ser mayor que 6 (es decir, al menos 7) para no detonar la bomba. Si todas las comprobaciones pasan, libera la memoria asignada y retorna con éxito; de lo contrario invoca explode_bomb.

"phase_4" En phase_4, el programa lee de una sola línea dos números enteros x e y mediante sscanf, calcula x = x & 0xF (equivalente a x mod 16) y rechaza inmediatamente si ese resultado es 15. A continuación inicia un bucle en el que, partiendo de idx = x, incrementa un contador y suma el valor table[idx] a un acumulador hasta encontrar el dato con valor 15, trasladando luego idx al valor leído en cada iteración. Para que la fase pase sin detonar la bomba, ese bucle debe ejecutarse exactamente 14 veces y la suma acumulada debe ser igual al segundo número y ingresado; en caso contrario, se invoca a explode_bomb.

"secret_phase" Durante el análisis del desensamblado nos dimos cuenta de que, tras superarse las cuatro fases principales y ejecutarse la rutina phase_defused, el código hacía una llamada a una función adicional llamada secret_phase, lo que nos indicó que había una “fase secreta” oculta. Al inspeccionar secret_phase vimos que esta función lee un único entero de la entrada, lo resta 1 y comprueba que no supere 1000, luego invoca a fun7(n1, v) con ese valor y solo continúa sin detonar la bomba si el retorno es exactamente 7. Para encontrar la clave, cargamos el binario en GDB, pusimos un breakpoint en secret_phase y ejecutamos un bucle que probaba todos los valores de 1 a 1001 llamando a fun7(n1, i); cuando fun7 devolvió 7, GDB nos imprimió inmediatamente el valor (1001), que resultó ser el entero correcto para desactivar la fase secreta.
